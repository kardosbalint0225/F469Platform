/*
 * sdmmc.h
 *
 *  Created on: 2023. okt. 15.
 *      Author: Balint
 */

#ifndef _SDMMC_H_
#define _SDMMC_H_

#include <errno.h>
#include <stdint.h>

/**
 * @brief   SDIO/SD/MMC device descriptor
 *
 * The device descriptor holds all required information about the SDIO/SD/MMC
 * device and the card that is used by this decive.
 *
 * @note Most of the information is determined or collected during the card
 *       initialization and identification procedure by the @ref sdmmc_card_init
 *       function. However, some information must be determined and collected
 *       by the low-level SDIO/SD/MMC peripheral driver. These are
 *       - @ref sdmmc_dev_t::driver
 *       - @ref sdmmc_dev_t::present
 *       - @ref sdmmc_dev_t::status
 *       - @ref sdmmc_dev_t::bus_width
 *       - @ref sdmmc_dev_t::spi_mode
 */
typedef struct sdmmc_dev {
    /**
     * Low-level SDIO/SD/MMC peripheral driver. It has to be set by the
     * low-level SDIO/SD/MMC driver during the initialization.
     */
    const sdmmc_driver_t *driver;

    /**
     * The application can register an event callback function of type
     * @ref sdmmc_event_cb_t which is called when one of the defined
     * events (@ref sdmmc_event_t) is generated by the SDIO/SD/MMC driver.
     *
     * @warning The function is called in the ISR context. Do not do anything
     *          comprehensive or time-consuming. Instead, use `thread_flags`,
     *          `event_queue` or `msg` mechanism to inform a thread about
     *          the event, which then handles the event asynchronously in
     *          thread context.
     */
    sdmmc_event_cb_t event_cb;

    /**
     * CID register of the SD/MMC Card, read during the initialization and
     * identification procedure in the @ref sdmmc_card_init function. It is not
     * supported by SDIO cards and reflects the CID of the memory portion in
     * case of Combo cards.
     */
    sdmmc_cid_t cid;

    /**
     * SCR register of the SD Card, read during the initialization and
     * identification procedure in the @ref sdmmc_card_init function. It is not
     * supported by SDIO and MMC cards. It reflects the SCR of the memory
     * portion in case of Combo cards.
     */
    sdmmc_scr_t scr;

    /**
     * CSD register of the SD/MMC Card, read during the initialization and
     * identification procedure in the @ref sdmmc_card_init function. It is not
     * supported by SDIO cards. It reflects the CSD of the memory portion in
     * case of Combo cards.
     */
    sdmmc_csd_t csd;

#if IS_USED(MODULE_SDMMC_MMC)
    /**
     * EXT_CSD register of the MMC Card, read during the initialization and
     * identification procedure int the @ref sdmmc_card_init function.
     */
    sdmmc_ext_csd_t ext_csd;
#endif

    /**
     * Last SDIO/SD/MMC Card status reported in R1 response. It is
     * set by the low-level SDIO/SD/MMC peripheral driver function
     * @ref sdmmc_driver_t::send_cmd.
     */
    uint32_t status;

    /**
     * Relative Card Address (RCA) of the SDIO/SD/MMC Card as determined
     * during the initialization and identification procedure in the
     * @ref sdmmc_card_init function.
     */
    uint16_t rca;

    /**
     * Type of the SDIO/SD/MMC Card as identified during the initialization and
     * identification procedure in the @ref sdmmc_card_init function
     * (default @ref SDMMC_CARD_TYPE_UNKNOWN).
     */
    sdmmc_card_type_t type;

    /**
     * Data bus width supported by the SDIO/SD/MMC device
     * (default @ref SDMMC_BUS_WIDTH_1BIT). It has to be set by the low-level
     * SDIO/SD/MMC peripheral driver function @ref sdmmc_driver_t::init.
     * It is either hard-configured for the SDIO/SD/MMC device or detected
     * during its initialization.
     */
    sdmmc_bus_width_t bus_width;

    /**
     * Indicates whether a card is present. It has to be set by the low-level
     * SDIO/SD/MMC peripheral driver in function @ref sdmmc_driver_t::init and
     * if the card is removed or inserted.
     * Either the CD signal is used if available, or it must be set to
     * `true` by default.
     */
    bool present;

    /**
     * Indicates whether the card is initialized (default `false`).
     * It is set by the initialization and identification procedure in
     * function @ref sdmmc_card_init.
     */
    bool init_done;

    /**
     * Indicates whether the SDIO/SD/MMC peripheral supports the switching
     * to 1.8V (default `false`). It has to be set by the low-level SDIO/SD/MMC
     * peripheral driver function @ref sdmmc_driver_t::init if supported.
     */
    bool s18v_support;

    /**
     * Indicates whether the card supports the switching to 1.8V (default
     * `false`). It is set during the initialization and identification
     * procedure in function @ref sdmmc_card_init.
     */
    bool s18v_allowed;

    /**
     * Indicates whether SPI mode is used by the SDIO/SD/MMC device (default
     * `false`). It has to be set by the low-level SDIO/SD/MMC peripheral driver
     * function @ref sdmmc_driver_t::init.
     */
    bool spi_mode;

} sdmmc_dev_t;

/**
 * @brief   Basic initialization of the given SDIO/SD/MMC device
 *
 * The function calls the low-level SDIO/SD/MMC peripheral driver function
 * @ref sdmmc_driver_t::init for the basic initialization of the SDIO/SD/MMC
 * peripheral including the configuration of used pins.
 *
 * If the `auto_init` module is enabled, it is called automatically during the
 * startup. Otherwise, it has to be called before the SDIO/SD/MMC device is
 * used for the first time.
 *
 * Errors like configuration parameter problems are not signaled by
 * return values, but by using the `assert()`.
 *
 * @see @ref sdmmc_driver_t::init
 * @pre @p dev must not be `NULL`.
 *
 * @param[in]   dev     SDIO/SD/MMC device to initialize
 */
void sdmmc_init(sdmmc_dev_t *dev);


/**
 * @brief Card Initialization and Identification
 *
 * This function identifies the type of used SDIO/SD/MMC Cards and
 * initializes them according to the standardized procedure specified in:
 *
 * - Physical Layer Simplified Specification Version 9.00,
 *   Section 4.2.3 Card Initialization and Identification Process, pp. 43
 *   [[sdcard.org](https://www.sdcard.org)]
 * - SDIO Simplified Specification Version 3.00,
 *   Section 3.1.2 Initialization by I/O Aware Host, pp. 17
 *   [[sdcard.org](https://www.sdcard.org)]
 * - SD Host Controller Simplified Specification Version 4.20,
 *   Section 3.6 Card Initialization and Identification (for SD I/F), pp. 160
 *   [[sdcard.org](https://www.sdcard.org)]
 * - JEDEC Standard No. JESD84-B42, MultiMediaCard (MMC) Electrical
 *   Standard, High Capacity (MMCA, 4.2),
 *   Section 7.2 Card Identification Mode, p. 24 and Figure 16 on p. 16
 *   [[jedec.org](https://www.jedec.org)]
 *
 * Identified card types are:
 * - SD Memory Cards with Standard Capacity (SDSC) Version 1.x, Version 2.x+
 * - SD Memory Cards with High or Extended Capacity (SDHC/SDXC)
 * - SDIO Cards, not supported yet
 * - Combined SDIO/SD Memory Cards (Combo Cards), SDIO part not supported yet
 * - MultiMedia Cards (MMC) and Embedded Multimedia Cards (eMMC)
 *
 * @warning  If the low-level SDIO/SD/MMC peripheral driver defines its own
 *           @ref sdmmc_driver_t::card_init function, this function is used
 *           instead. \n
 *           However, the low-level SDIO/SD/MMC peripheral driver should
 *           define its own @ref sdmmc_driver_t::card_init function only in
 *           very special cases, e.g. when special hardware handling is
 *           required. Otherwise it is strongly recommended to set
 *           sdmmc_driver_t::card_init to `NULL` and to use the default
 *           procedure implemented by @ref sdmmc_send_acmd.
 *
 * @see @ref sdmmc_driver_t::card_init
 * @pre @p dev must not be `NULL`.
 *
 * @param[in]   dev     SDIO/SD/MMC device to be used
 *
 * @retval  0           on success
 * @retval  -ENODEV     if card is not present or not usable
 * @retval  -ENOTSUP    if card is not supported or can't operate under supplied voltage
 * @retval  -EFAULT     on card status error
 * @retval  -ETIMEDOUT  on card initialization and identification timeout
 * @retval  -EBADMSG    on CRC7 error
 * @retval  -EIO        on not further specified error incl. hardware errors
 */
int sdmmc_card_init(sdmmc_dev_t *dev);


/**
 * @brief   Read a number of blocks
 *
 * Read @p block_num blocks with size @p block_size from @p dev starting at
 * block address @p block_addr to buffer @p data.
 *
 * The starting block address is always specified as block address independent
 * on the actual addressing scheme of used card. The driver takes care of
 * mapping to byte addressing if needed.
 *
 * If the parameter @p done is not `NULL`, the function returns the number of
 * read blocks.
 *
 * @warning
 * The buffer @p data may need to be word-aligned depending on CPU-specific
 * requirements. @ref sdmmc_buf_t or @ref SDMMC_CPU_DMA_REQUIREMENTS have to
 * be used to define the buffer:
 * ```c
 * sdmmc_buf_t buffer[SDMMC_SDHC_BLOCK_SIZE];
 * ...
 * SDMMC_CPU_DMA_REQUIREMENTS uint8_t buffer[SDMMC_SDHC_BLOCK_SIZE];
 * ```
 *
 * @note @ref sdmmc_card_init is called implicitly if necessary.
 *
 * @pre @p dev and @p data must not be `NULL`.
 *
 * @param[in]   dev         SDIO/SD/MMC device to be used
 * @param[in]   block_addr  Start address to read from given as block address
 * @param[in]   block_size  Block size dependent on card and mode used
 *                          - 512 bytes for block-oriented transfers (SDSC V2.x/SDHC/SDXC)
 *                          - 1, 2, 4, ... 4096 for block-oriented transfers (MMC)
 *                          - 512, 1024, 2048 for block-oriented transfers (SDSC V1.x)
 *                          - 1...512 bytes in byte/multibyte mode (SDIO only)
 *                          - 0 in stream mode (MMC only)
 * @param[in]   block_num   Number of blocks:
 *                          - 1, ... for block-oriented transfers (SD Card/MMC)
 *                          - 1 in byte/multibyte mode (SDIO only)
 *                          - 0 in stream mode (MMC only)
 * @param[out]  data        Buffer for read data
 * @param[out]  done        Number of read blocks, can be `NULL`
 *
 * @retval  0           on success, @p block_num blocks were read successfully
 * @retval  -ENODEV     if card is not present or not usable
 * @retval  -ENOTSUP    if card does not support a used command or is in wrong state
 * @retval  -EBUSY      if card is busy
 * @retval  -EFAULT     on card status error
 * @retval  -ETIMEDOUT  on timeout condition
 * @retval  -EINVAL     on invalid transfer parameters
 * @retval  -EBADMSG    on CRC7 error
 * @retval  -ENOMEM     on RX FIFO overflow error
 * @retval  -EIO        on not further specified error incl. hardware errors
 */
int sdmmc_read_blocks(sdmmc_dev_t *dev, uint32_t block_addr, uint16_t block_size,
                      uint16_t block_num, void *data, uint16_t *done);

/**
 * @brief   Write a number of blocks
 *
 * Write @p block_num blocks with size @p block_size to @p dev starting at
 * block address @p block_addr from buffer @p data.
 *
 * The starting block address is always specified as block address independent
 * on the actual addressing scheme of used card. The driver takes care of
 * mapping to byte addressing if needed.
 *
 * If the parameter @p done is not `NULL`, the function returns the number of
 * written blocks.
 *
 * @warning
 * The buffer @p data may need to be word-aligned depending on CPU-specific
 * requirements. @ref sdmmc_buf_t or @ref SDMMC_CPU_DMA_REQUIREMENTS have to
 * be used to define the buffer:
 * ```c
 * sdmmc_buf_t buffer[SDMMC_SDHC_BLOCK_SIZE];
 * ...
 * SDMMC_CPU_DMA_REQUIREMENTS uint8_t buffer[SDMMC_SDHC_BLOCK_SIZE];
 * ```
 *
 * @note @ref sdmmc_card_init is called implicitly if necessary.
 *
 * @pre @p dev and @p data must not be `NULL`.
 *
 * @param[in]   dev         SDIO/SD/MMC device to be used
 * @param[in]   block_addr  Start address to write to given as block address
 * @param[in]   block_size  Block size dependent on card and mode used
 *                          - 512 bytes for block-oriented transfers (SDSC V2.x/SDHC/SDXC)
 *                          - 1, 2, 4, ... 4096 for block-oriented transfers (MMC)
 *                          - 512, 1024, 2048 for block-oriented transfers (SDSC V1.x)
 *                          - 1...512 bytes in byte/multibyte mode (SDIO only)
 *                          - 0 in stream mode (MMC only)
 * @param[in]   block_num   Number of blocks:
 *                          - 1, ... for block-oriented transfers (SD and MMC)
 *                          - 1 in byte/multibyte mode (SDIO only)
 *                          - 0 in stream mode (MMC only)
 * @param[in]   data        Buffer with data to write
 * @param[out]  done        Number of blocks written, can be `NULL`
 *
 * @retval  0           on success, @p block_num blocks were read successfully
 * @retval  -ENODEV     if card is not present or not usable
 * @retval  -ENOTSUP    if card does not support a used command or is in wrong state
 * @retval  -EBUSY      if card is busy
 * @retval  -EFAULT     on card status error
 * @retval  -ETIMEDOUT  on timeout condition
 * @retval  -EINVAL     on invalid transfer parameters
 * @retval  -EBADMSG    on CRC7 error
 * @retval  -ENOMEM     on TX FIFO underrun error
 * @retval  -EIO        on not further specified error incl. hardware errors
 */
int sdmmc_write_blocks(sdmmc_dev_t *dev, uint32_t block_addr, uint16_t block_size,
                       uint16_t block_num, const void *data, uint16_t *done);

/**
 * @brief   Erase a number of blocks
 *
 * Erase @p block_num blocks starting at block address @p block_addr on
 * SD/MMC Card device.
 *
 * The starting block address is always specified as block address independent
 * on the actual addressing scheme of used card. The driver takes care of
 * mapping to byte addressing if needed.
 *
 * @note    This function is only available for SD Memory Cards, MMC Cards
 *          or the SD Memory Card portion of a combined SDIO/SD Memory Card
 *          (Combo Card). Calling this function for a SDIO only card returns
 *          the `-ENOTSUP` error.
 *
 * @note @ref sdmmc_card_init is called implicitly if necessary.
 *
 * @pre @p dev must not be `NULL`. @p block_num has to be greater than 0.
 *
 * @param[in]   dev         SD/MMC device to be used
 * @param[in]   block_addr  Start address for erase given as block address
 * @param[in]   block_num   Number of blocks to be erased
 *
 * @retval  0           on success, @p block_num blocks were erased successfully
 * @retval  -ENODEV     if card is not present or not usable
 * @retval  -ENOTSUP    if card does not support erase operation or a command used
 * @retval  -EBUSY      if card is busy
 * @retval  -EFAULT     on card status error
 * @retval  -ETIMEDOUT  on timeout condition
 * @retval  -EBADMSG    on CRC7 error in response
 * @retval  -EINVAL     on invalid erase parameters
 * @retval  -EIO        on not further specified error incl. hardware errors
 */
int sdmmc_erase_blocks(sdmmc_dev_t *dev, uint32_t block_addr, uint16_t block_num);

/**
 * @brief   Get Capacity of SD/MMC Card
 *
 * Get the capacity of a SD/MMC Card device.
 *
 * @note    This function is only available for SD Memory Cards, MMC Cards
 *          or the SD Memory Card portion of a combined SDIO/SD Memory Card
 *          (Combo Card). Calling this function for a SDIO only card returns
 *          the `-ENOTSUP` error.
 *
 * @note @ref sdmmc_card_init is called implicitly if necessary.
 *
 * @pre @p dev must not be `NULL`.
 *
 * @param[in]   dev     SD/MMC device to be used
 *
 * @return  the capacity in in byte or 0 on error
 */
uint64_t sdmmc_get_capacity(sdmmc_dev_t *dev);

#endif /* INCLUDE_SDMMC_H_ */
